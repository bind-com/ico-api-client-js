/* tslint:disable */
/* eslint-disable */
/**
 * BIND ICO portal API
 * Description for BIND. 
 *
 * OpenAPI spec version: 2.0
 * Contact: support@bind.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { CurrentPriceResponse } from '../models';
import { DetailedBalanceResponse } from '../models';
import { InlineResponse200 } from '../models';
import { OrderedTokensResponse } from '../models';
import { PaymentLinkInput } from '../models';
import { PaymentLinkResult } from '../models';
import { TokenRaiseResult } from '../models';
/**
 * TokenApi - axios parameter creator
 * @export
 */
export const TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a payment link to purchase BIND tokens
         * @summary Create a payment link to purchase BIND tokens
         * @param {PaymentLinkInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentLink: async (body?: PaymentLinkInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment_link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * BIND token balance, purchase price, current price, listing price
         * @summary Get current User's balance of BIND token with some details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailedBalance: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/detailed_balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get datetime of next price update
         * @summary Get datetime of next price update
         * @param {string} X_User_Timezone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextPriceDatetime: async (X_User_Timezone: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'X_User_Timezone' is not null or undefined
            if (X_User_Timezone === null || X_User_Timezone === undefined) {
                throw new RequiredError('X_User_Timezone','Required parameter X_User_Timezone was null or undefined when calling getNextPriceDatetime.');
            }
            const localVarPath = `/next_price_datetime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_User_Timezone !== undefined && X_User_Timezone !== null) {
                localVarHeaderParameter['X-User-Timezone'] = String(X_User_Timezone);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get number of all ordered tokens, their total price and number of minted tokens
         * @summary Number of ordered tokens
         * @param {string} [currency_id] Id of a currency to measure BIND token price. Defaults to USD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderedTokens: async (currency_id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ordered_tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (currency_id !== undefined) {
                localVarQueryParameter['currency_id'] = currency_id;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current price of a BIND token and a currency that was used to measure token's price
         * @summary Current price of a BIND token
         * @param {string} [currency_id] Id of a currency to measure BIND token price. Defaults to USD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrice: async (currency_id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bind_price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (currency_id !== undefined) {
                localVarQueryParameter['currency_id'] = currency_id;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a bind token raise end date
         * @summary Token raise end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenRaiseEnd: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token_raise_end`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a bind token raise start date
         * @summary Token raise start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenRaiseStart: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token_raise_start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a payment link to purchase BIND tokens
         * @summary Create a payment link to purchase BIND tokens
         * @param {PaymentLinkInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentLink(body?: PaymentLinkInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PaymentLinkResult>>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).createPaymentLink(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * BIND token balance, purchase price, current price, listing price
         * @summary Get current User's balance of BIND token with some details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailedBalance(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<DetailedBalanceResponse>>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).getDetailedBalance(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get datetime of next price update
         * @summary Get datetime of next price update
         * @param {string} X_User_Timezone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNextPriceDatetime(X_User_Timezone: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200>>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).getNextPriceDatetime(X_User_Timezone, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get number of all ordered tokens, their total price and number of minted tokens
         * @summary Number of ordered tokens
         * @param {string} [currency_id] Id of a currency to measure BIND token price. Defaults to USD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderedTokens(currency_id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<OrderedTokensResponse>>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).getOrderedTokens(currency_id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get current price of a BIND token and a currency that was used to measure token's price
         * @summary Current price of a BIND token
         * @param {string} [currency_id] Id of a currency to measure BIND token price. Defaults to USD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrice(currency_id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CurrentPriceResponse>>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).getPrice(currency_id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a bind token raise end date
         * @summary Token raise end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenRaiseEnd(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TokenRaiseResult>>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).getTokenRaiseEnd(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a bind token raise start date
         * @summary Token raise start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenRaiseStart(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TokenRaiseResult>>> {
            const localVarAxiosArgs = await TokenApiAxiosParamCreator(configuration).getTokenRaiseStart(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a payment link to purchase BIND tokens
         * @summary Create a payment link to purchase BIND tokens
         * @param {PaymentLinkInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentLink(body?: PaymentLinkInput, options?: AxiosRequestConfig): Promise<AxiosResponse<PaymentLinkResult>> {
            return TokenApiFp(configuration).createPaymentLink(body, options).then((request) => request(axios, basePath));
        },
        /**
         * BIND token balance, purchase price, current price, listing price
         * @summary Get current User's balance of BIND token with some details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailedBalance(options?: AxiosRequestConfig): Promise<AxiosResponse<DetailedBalanceResponse>> {
            return TokenApiFp(configuration).getDetailedBalance(options).then((request) => request(axios, basePath));
        },
        /**
         * Get datetime of next price update
         * @summary Get datetime of next price update
         * @param {string} X_User_Timezone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNextPriceDatetime(X_User_Timezone: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200>> {
            return TokenApiFp(configuration).getNextPriceDatetime(X_User_Timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * Get number of all ordered tokens, their total price and number of minted tokens
         * @summary Number of ordered tokens
         * @param {string} [currency_id] Id of a currency to measure BIND token price. Defaults to USD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderedTokens(currency_id?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<OrderedTokensResponse>> {
            return TokenApiFp(configuration).getOrderedTokens(currency_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current price of a BIND token and a currency that was used to measure token's price
         * @summary Current price of a BIND token
         * @param {string} [currency_id] Id of a currency to measure BIND token price. Defaults to USD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrice(currency_id?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<CurrentPriceResponse>> {
            return TokenApiFp(configuration).getPrice(currency_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a bind token raise end date
         * @summary Token raise end
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenRaiseEnd(options?: AxiosRequestConfig): Promise<AxiosResponse<TokenRaiseResult>> {
            return TokenApiFp(configuration).getTokenRaiseEnd(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a bind token raise start date
         * @summary Token raise start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenRaiseStart(options?: AxiosRequestConfig): Promise<AxiosResponse<TokenRaiseResult>> {
            return TokenApiFp(configuration).getTokenRaiseStart(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
    /**
     * Create a payment link to purchase BIND tokens
     * @summary Create a payment link to purchase BIND tokens
     * @param {PaymentLinkInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public async createPaymentLink(body?: PaymentLinkInput, options?: AxiosRequestConfig) : Promise<AxiosResponse<PaymentLinkResult>> {
        return TokenApiFp(this.configuration).createPaymentLink(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * BIND token balance, purchase price, current price, listing price
     * @summary Get current User's balance of BIND token with some details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public async getDetailedBalance(options?: AxiosRequestConfig) : Promise<AxiosResponse<DetailedBalanceResponse>> {
        return TokenApiFp(this.configuration).getDetailedBalance(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get datetime of next price update
     * @summary Get datetime of next price update
     * @param {string} X_User_Timezone 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public async getNextPriceDatetime(X_User_Timezone: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200>> {
        return TokenApiFp(this.configuration).getNextPriceDatetime(X_User_Timezone, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get number of all ordered tokens, their total price and number of minted tokens
     * @summary Number of ordered tokens
     * @param {string} [currency_id] Id of a currency to measure BIND token price. Defaults to USD
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public async getOrderedTokens(currency_id?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<OrderedTokensResponse>> {
        return TokenApiFp(this.configuration).getOrderedTokens(currency_id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get current price of a BIND token and a currency that was used to measure token's price
     * @summary Current price of a BIND token
     * @param {string} [currency_id] Id of a currency to measure BIND token price. Defaults to USD
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public async getPrice(currency_id?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<CurrentPriceResponse>> {
        return TokenApiFp(this.configuration).getPrice(currency_id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a bind token raise end date
     * @summary Token raise end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public async getTokenRaiseEnd(options?: AxiosRequestConfig) : Promise<AxiosResponse<TokenRaiseResult>> {
        return TokenApiFp(this.configuration).getTokenRaiseEnd(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a bind token raise start date
     * @summary Token raise start
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public async getTokenRaiseStart(options?: AxiosRequestConfig) : Promise<AxiosResponse<TokenRaiseResult>> {
        return TokenApiFp(this.configuration).getTokenRaiseStart(options).then((request) => request(this.axios, this.basePath));
    }
}
